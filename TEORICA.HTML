<!--
Integrantes do grupo:
*Bruno Salles
*Roberto Eduardo
*Emanuel Costa
*Felipe Augusto
*Paulo César de Figuereido Sousa
Link para o GitHub: https://github.com/robertoeduardomd/pesquisaporcep
-->

<!-- 
Parte 1: elabore uma pesquisa sobre:
Breve definição e pequenos trechos de código para exemplificar.
-->

<!-- 
1) Assincronismo. 

assíncronismo diz respeito ao fluxo de execução de um programa. Quando uma operação executa completamente antes de passar o controle à seguinte, a execução é síncrona. Esse é o método padrão de execução de código nas linguagens que eu conheço, e imagino que também na maioria das que não conheço.


CODIGO:
-->
 $.get('http://example.com', funcaoQueExecutaQuandoRespostaChegar); // o código seguinte executa antes da resposta da requisição acima fazAlgumaCoisa(); // e a declaração do callback function funcaoQueExecutaQuandoRespostaChegar(resposta) { // a resposta não pode ser usada fora daqui, // a menos que você a passe, a partir daqui, // para uma outra função }

<!-- 
2) AJAX (Asynchronous Javascript And XML)

 Ajax é uma técnica de de desenvolvimento web em java script que permite que a pagina atualize automaticamente sem que tenha a necessidade de ter o trabalho de recarregar a pagina manualmente

CODIGO:
-->
function buscarProdutos(termo) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', 'busca.php?termo=' + termo, true);
  xhr.onload = function() {
    if (xhr.status === 200) {
      const resultados = document.getElementById('resultados');
      resultados.innerHTML = xhr.responseText;
    } else {
      console.error('Erro na requisição');
    }
  };
  xhr.send();
}

<!-- 
3) Promises 


 É um objeto que representa o estado de uma operação assíncrona e o seu valor resultante, ele retorna uma função assíncrona e oferece métodos para tratar exceções ou falhas


CODIGO:
-->
function obterDados(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(JSON.parse(xhr.responseText));
      } else {
        reject(new Error('Falha ao obter dados'));
      }
    };
    xhr.onerror = () => {
      reject(new Error('Erro de rede'));
    };
    xhr.send();
  });
}

obterDados('https://api.example.com/dados')
  .then(dados => {
    console.log('Dados recebidos:', dados);
  })
  .catch(error => {
    console.error('Erro:', error);
  });

<!-- 
4) fetch API

 É uma interface javascript que permite manipular partes do HTTP como pedidos e respostas ideal para mexer com APIS ,ele permite buscar recursos assíncronos

CODIGO:
-->
fetch('https://api.example.com/dados')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Erro:', error));

<!-- 
5) Async / Await

É uma abordagem em java script para escrever um código assíncrono de maneira mais legível e eficiente

CODIGO:
-->
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}

fetchData();

<!-- 
Quais vantagens/desvantagens de usar cada uma das opções acima?

AJAX (XMLHttpRequest): desvantagens: suas sintaxes são complexas,pouco flexível requer muito código para realizar tarefas comuns; 
vantagens: ele tem compatibilidade extensa funciona na maioria dos navegadores e até mesmo mais antigos, e um bom controle de monitoramento

Fetch API: desvantagens:falhas silenciosas,suporte limitado em prograsso de download e upload,não écompativel com navegadores antigos; 
vantagens: sintaxe simples e limpa de facil compreensão, compatível com JSON lida facilmente com conversões,melhor integração e suporte com promisses

Async/Await: desvantagens: Dependencia de promisses,necessário ambiente moderno para ter compatibilidade,tratamentos paralelos e loops limitados deixando ele ineficiente nesse quesito; 
vantagens: código mais limpo e linear,tratamento de erros unificado e mais intuitivo utilizando o try,catch,melhor fluxo de controle facilita o gerenciamento de operações assincronas

6) Hoisting

O Hoisting é o comportamento padrão do JavaScript de mover as declarações para o topo do seu escopo antes da execução do código, não importa se o escopo seja global ou local. Se você já se perguntou o porque é capaz de chamar funções antes mesmo das linhas em que elas estão escritas, aqui está o motivo.
 o hoisting acontece apenas para declarações e não para inicializações ou atribuições.

CODIGO:
-->
console.log(x);
var x = 10;


<!-- 
7) Arrow Functions (especialmente diferenças com relação as funções normais)

arrow functions são uma sintaxe mais concisa introduzida no ECMAScript 6 (ES6) para criar funções em JavaScript. Elas oferecem uma forma mais elegante de escrever funções, especialmente quando se trata de funções curtas ou de callback.

CODIGO:
-->
(parâmetros) => { corpo da função }

const soma = (a, b) => {
  return a + b;
};

<!-- 
8) Desestruturação (Destructuring)
    
    
CODIGO:
-->

<!-- 
9) Clojure

CODIGO:
-->
